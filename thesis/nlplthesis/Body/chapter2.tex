% Chapter 2 of the Thesis Template File
%   which includes bibliographic references.
\chapter{REVIEW OF LITERATURE}
In this chapter, we will overview main differences between NL versus PL and understand meaning of each natural language elements. To get this summarization of problems between two languages, we rely on problems between NL and PL listed in \cite{} and problems we found.
\section{Differences between Natural Language and Programming Language}
According to \cite{}, programming language has limit language expressiveness while natural language description has stronger expressiveness.  In natural language, there are linguistic elements that have a different level of expressiveness compare to programming language.
\subsection{Deixis}
According to Oxford English Dictionary, "deixis" means "the function or use of deictic words or expressions whose meaning depends on where, when, or by whom they are used". In other words,this concept highlight that in natural language, there are words that their meaning depend on the context. Deixis are used to express the sentence in  shorter way without losing its meaning. In the direction of NL to PL, along with the context of NL, we have the context from the surrounding source code. \\

Let's look at an example of deixis in this code snippet. In this example, "a file" here has the reference to the type "java.io.File". In this context, although the description mentioned only about a class name. There are several ways for describe an object as "deixis" like using pronouns such as "it" or "they". In the other words, deixis provides a type of indirect reference between object in natural language and object in implementation. \\

Another example is in figure \cite{}. In this example, the verb "create" will be understood as an constructor of the DataInputStream object, with the respected argument as a file name mentioned in the NL description. This case shows another example of indirect reference, which map a verb to a constructor statement in Java. There are multi types of deixis between NL and PL which hindered automatically approach like NMT to study this mapping based on the problem of indirect references. 

\subsection{Expressiveness}
In Oxford Dictionary, expressiveness means "showing or able to show your thoughts and feelings". In NL, expressiveness helps users to describe their ideas in many ways.  This is due to the fact that English can cover a large set of lexical rules, grammatical rules and textual rules. \cite{} shows that there are different set of rules between different subset language of English. In the area of NL to PL, natural languages have implicit references for expressing ideas while programming language used a very explicit references. For example, we can easily see natural language description contains "previous", "next" but in the corresponding implementation, we can only have number and variables. \\
NL and PL have a very separate mechanism of managing the expressiveness in description related to control structures. An example is shown in figure \cite{}. In this example, the description mentioned about if and otherwise case about a boolean condition. However, in the implementation, the code for the implementation is the if-then-else structure. The order of description of statement of else branch is before the term "otherwise", while "else" keyword should be before this statement in the implementation. Along with basic control structure, we can face the problem of expressiveness in many other structure and algorithms, like loop and recursion. The different of expressiveness causes the mismatch between learning the control structure of programming language given the natural language description. 
\subsection{Phrases}
Natural Language description consists of one or more phrases. In NL to PL, each phrase may have a specific semantic  meaning related to variables and statements. Phrases can be very complex and can be ambiguous about their mapping in the PL. Several phrases can be mapped to one statement in the implementation, while several sentences can be mapped to single control structure. \\

In example 1 figure \cite{}, we can see that two phrases of the description "create bit set and set its 5th element to true" corresponded to one method invocation, in which the first phrase is the receiver while the second phrase mentioned about the method identifier and expected method argument. The differences in phrase translation rules can be shown on example 2. In this example, two sentences in the documentation actually mentioned about If branch and else branch of an if statement. In general, the mapping of phrase to statement in NL to PL is not one one mapping. The mapping rules between phrase in NL and statement in PL might depends on types of phrase along with context of description.
   
\subsection{Anaphoric Relations}
In natural languages, abstraction of types are not only in the form of class name like example we show in deixis but also in the form of providing description relate to class properties and methods. An example of anaphoric relations is  shown in example \cite{}. In the NL description, a noun phrase "dog" actually refers to a class name and the verb "is barking" mentioned about method bark() defined inside a Dog class. This description implies about a validation for NL description, in which ensure that bark() has to be a method of Dog object. Depending on paradigm of programming language, the corresponding implementation may be differed. For example, in object-oriented language, we must assured that the project contains this description has definition of Dog class with bark() method, while in functional language like C or Pascal, we valid our program by finding a function bask() that accept a struct "Dog". \\

Along with deixis, anaphoric relations provides the full support for indirect reference between NL and PL. While deixis relate to how to mention about a type information in form of class name only or pronoun, anaphoric relations focuses on expression every properties of an instance, including its methods and fields. A common of type of this relation is relation between verb to method invocation. When you see a verb in NL description along with a class name like figure \cite{}. it has the potential that the corresponding implementation is about a method invocation of the class name in NL description. 
\subsection{Context}
To realizing literate programming, context is an important element deciding the correctness of natural language to programming language translation. Unlike NL-to-NL translation which considered the context such as surrounding phrases or surrounding sentences given an input, the NL-to-PL considered both the natural language side and programming language side as context of given NL description. \\

Given a NL description, its related implementation might depend on surrounding NL description. In the example in figure \cite{}. the phrase "set its 5th element to true" has a translated result as a method invocation "set" of java.util.BitSet object. We know about the receiver of this implementation based on the previous phrase "create bit set", which provides us information about a BitSet object. If we don't have the first phrase, we cannot inferred to the correct set method invocation, though we have method name along with parameters. \\

Along with context from NL part, information from programming language part brings an essential context for NL description. Let's see example 2 from figure. In here, unlike example 1, we don't have information about the constructor of Bit Set. However, we can predict about the receiver of "set" method identifier based on the surrounding code, in which we have the information about a BitSet object. Context of PL parts provides all possible variables and class name are valid to use for the NL description. Context at PL level helps to restrict the implementation parts only relate to APIs that define in the scope of project, including its imported jar file and source code files. In our knowledge, current techniques for generating code from natural language considered the NL context as a full context and skip the information about surrounding code like AnyCode . In AnyCode, each NL description solved as a query for code instead of a comment, which hinders its ability for realizing literate programming, which requires NL descriptions consistent with surrounding NL context and PL context.

\subsection{Ambiguity}
Ambiguity in NL to PL translation means that one element in NL may has many interpretations, which the correct one may be varied based on the context. We can manually check to find the correct interpretation but an automatic translation engine doesn't have the ability to do that. To allow reasoning and de-ambiguous the translation result, we need to study types of ambiguity and design an algorithm for reasoning. In our knowledge, their are 2 important types of ambiguity in NL side and PL sides. \\
In NL side, noun and verb are two popular elements that have ambiguous in translated results. With noun, class name in NL might have more than one type annotation in PL. Information of correct type annotations can depend on the context of source file projects. In example show in figure \cite{}, the class name "URL" has several type annotations, in which the most popular one is "java.net.URL", With verb, the ambiguity can happen between statement trigger or method invocation. In example 1 show on figure \cite{}, the "set" verb is a assignment statement in the implementation, while in example 2 it is a method invocation set of Hash Map. There are several information from context can differentiate between two cases. In example one, the verb is used with a variable, a preposition "to" and a value that have the same type with a variable. In example two, the verb is used with two variable written consecutively. We can rely on such information to make correct reasoning.  \\
In PL side, ambiguous can happen between translating verb as method invocation. One verb can be translated to multiple invocations. In the example show in figure \cite{}, there are 12 method APIs named set in libraries of JDK and apache common io. They have the same identifiers but their behavior are differed from each other, based on their receiver and argument. To reason the correct API for verbs, relying on the NL context including variables and value defined in the NL description might be a good direction. In overall, ambiguous is one of the most challenges for NL-to-PL translation, which make code query system like \cite{} cannot be used for literate programming, since it doesn't use enough context in PL for reasoning the correct interpretation. 
     
\section{Elements  of a Natural Language parser}

Stanford NLP \cite{} is one of the most popular Natural Language Processing toolkits. The core of Stanford NLP is based on its Stanford Parser. Stanford parser is a natural language parser, which analyses the grammatical structure of sentences and identifying type of words, such as verb, subject or object. Stanford Parser uses probabilistic parser, which uses information from corpus of sentences parsed manually to analyze new sentence. The output of this parser is an natural language parsed tree, which is important in NL to PL translation systems such as AnyCode \cite{}. In this tree, each nodes will belong to one type of the Penn Treebank tags \cite{}. In this section, we study the purpose of each Treebank tags and its context in NL description for PL. In total, there are 82 tags defined in \cite{}. In these tags. 36 tags are frequently used in  NL descriptor which belongs to 3 types: clause, phrase and word level. This section will introduce 

\subsection{Clause level tags}
Clause level tags are elements for representing a grammar structure of sentences. The most frequent type of clause is the simple declarative clause which has abbreviation S. S is the basic blocks for conversation and writing \cite{}. The grammar of declarative sentence usually contains subject, verb and object. An example of S is shown in \cite{}. \\
Along with declarative sentence, NL grammar allows other types of sentences such as interrogate, imperative or exclamatory. There are 4 other types of clause defined by PennTree Bank: SBAR, SBARQ, SINV and SQ. SBAR stands for subordinate clause. It usually begin with subordinating conjunction along with a simple declarative clause. For example, we can add "after" to "she ate breakfast" to make an example of SBAR. In NL description for PL, we can see SBAR frequently in the form of "if" clause. In example ?, "if" solved as subordinating conjunction before description of boolean condition "a is greater than zero". SBARQ stands for direct question introduced by wh-word or wh-phrase. Since NL description is usually a description about behavior of implementation, SBARQ rarely see in NL to PL translation. SINV is the inverted declarative sentence, which usually has past tense verb in its content like case in example. SQ is a question that have yes/no answer. Differ from SBARQ question, SQ sentences don't start with wh-element. An example of SBARQ is shown in case of \cite{}. 
\subsection{Phrase level tags}
\subsection{Word level tags}

